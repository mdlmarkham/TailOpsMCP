#!/bin/bash\n# Proxmox API Helper Library\n# Functions for managing LXC containers from the Proxmox host\n\n# Source common functions if not already loaded\nif [ -z "$SYSTEMMANAGER_COMMON_LOADED" ]; then\n    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"\n    # shellcheck source=scripts/install/lib/common.sh\n    source "$SCRIPT_DIR/common.sh"\nfi\n\n# Check if running on Proxmox host\ncheck_proxmox_host() {\n    if ! command -v pct >/dev/null 2>&1; then\n        log_error "This script must be run on a Proxmox VE host"\n        log_error "The 'pct' command is not available"\n        return 1\n    fi\n\n    if [ ! -d "/etc/pve" ]; then\n        log_error "Proxmox VE configuration directory not found"\n        return 1\n    fi\n\n    log_success "Running on Proxmox VE host"\n    return 0\n}\n\n# Check if container exists\ncontainer_exists() {\n    local ctid="$1"\n    pct status "$ctid" >/dev/null 2>&1\n    return $?\n}\n\n# Get container status\nget_container_status() {\n    local ctid="$1"\n    pct status "$ctid" 2>/dev/null | awk '{print $2}'\n}\n\n# Start container if not running\nensure_container_running() {\n    local ctid="$1"\n    local status\n\n    status=$(get_container_status "$ctid")\n\n    if [ "$status" = "running" ]; then\n        log_info "Container $ctid is already running"\n        return 0\n    fi\n\n    log_info "Starting container $ctid..."\n    if pct start "$ctid"; then\n        # Wait for container to fully start\n        sleep 3\n        log_success "Container $ctid started successfully"\n        return 0\n    else\n        log_error "Failed to start container $ctid"\n        return 1\n    fi\n}\n\n# Stop container\nstop_container() {\n    local ctid="$1"\n    local timeout="${2:-30}"\n\n    log_info "Stopping container $ctid..."\n    if pct stop "$ctid" --timeout "$timeout"; then\n        log_success "Container $ctid stopped successfully"\n        return 0\n    else\n        log_error "Failed to stop container $ctid"\n        return 1\n    fi\n}\n\n# Check if container has required features\ncheck_container_features() {\n    local ctid="$1"\n    local config_file="/etc/pve/lxc/${ctid}.conf"\n    local issues=()\n\n    log_info "Checking container $ctid features..."\n\n    # Check for nesting (required for Docker)\n    if ! grep -q "^features:.*nesting=1" "$config_file"; then\n        issues+=("nesting=1 not enabled (required for Docker)")\n    fi\n\n    # Check for keyctl (recommended for Docker)\n    if ! grep -q "^features:.*keyctl=1" "$config_file"; then\n        issues+=("keyctl=1 not enabled (recommended for Docker)")\n    fi\n\n    # Check for TUN device (required for Tailscale)\n    if ! grep -q "^lxc.cgroup2.devices.allow:.*c 10:200 rwm" "$config_file" && \\n       ! grep -q "^lxc.cgroup.devices.allow:.*c 10:200 rwm" "$config_file"; then\n        issues+=("TUN device not enabled (required for Tailscale)")\n    fi\n\n    if [ ${#issues[@]} -gt 0 ]; then\n        log_warning "Container $ctid has configuration issues:"\n        for issue in "${issues[@]}"; do\n            log_warning "  - $issue"\n        done\n        return 1\n    else\n        log_success "Container $ctid has all required features"\n        return 0\n    fi\n}\n\n# Fix container features\nfix_container_features() {\n    local ctid="$1"\n    local config_file="/etc/pve/lxc/${ctid}.conf"\n    local needs_restart=false\n\n    log_info "Configuring container $ctid features..."\n\n    # Stop container if running\n    if [ "$(get_container_status "$ctid")" = "running" ]; then\n        stop_container "$ctid" || return 1\n        needs_restart=true\n    fi\n\n    # Enable nesting and keyctl\n    if ! grep -q "^features:" "$config_file"; then\n        echo "features: nesting=1,keyctl=1" >> "$config_file"\n    else\n        # Update existing features line robustly (avoid duplicates)\n        current_features=$(grep '^features:' "$config_file" | head -n1 | cut -d':' -f2- | tr -d ' ')\n        new_features="$current_features"\n        # Add nesting=1 if missing\n        if ! echo ",$new_features," | grep -q ",nesting=1,"; then\n            if [ -n "$new_features" ]; then\n                new_features="$new_features,nesting=1"\n            else\n                new_features="nesting=1"\n            fi\n        fi\n        # Add keyctl=1 if missing\n        if ! echo ",$new_features," | grep -q ",keyctl=1,"; then\n            if [ -n "$new_features" ]; then\n                new_features="$new_features,keyctl=1"\n            else\n                new_features="keyctl=1"\n            fi\n        fi\n        # Replace the features line with the updated one\n        sed -i "s/^features:.*/features: $new_features/" "$config_file"\n    fi\n\n    # Enable TUN device for Tailscale\n    if ! grep -q "^lxc.cgroup2.devices.allow:.*c 10:200 rwm" "$config_file"; then\n        echo "lxc.cgroup2.devices.allow: c 10:200 rwm" >> "$config_file"\n        echo "lxc.mount.entry: /dev/net dev/net none bind,create=dir" >> "$config_file"\n    fi\n\n    # Set AppArmor to unconfined (recommended for nested containers)\n    if ! grep -q "^lxc.apparmor.profile:" "$config_file"; then\n        echo "lxc.apparmor.profile: unconfined" >> "$config_file"\n    fi\n\n    log_success "Container $ctid features configured"\n\n    # Restart if it was running\n    if [ "$needs_restart" = true ]; then\n        ensure_container_running "$ctid" || return 1\n    fi\n\n    return 0\n}\n\n# Execute command in container\nexec_in_container() {\n    local ctid="$1"\n    shift\n    local cmd="$*"\n\n    pct exec "$ctid" -- bash -c "$cmd"\n    return $?\n}\n\n# Copy file to container\ncopy_to_container() {\n    local ctid="$1"\n    local source="$2"\n    local dest="$3"\n\n    log_info "Copying $source to container $ctid:$dest"\n\n    # Use pct push\n    if pct push "$ctid" "$source" "$dest"; then\n        log_success "File copied successfully"\n        return 0\n    else\n        log_error "Failed to copy file"\n        return 1\n    fi\n}\n\n# Get container IP address\nget_container_ip() {\n    local ctid="$1"\n    local ip\n\n    # Try to get IP from container's network interface\n    # Dynamically detect the primary network interface (excluding 'lo')\n    local iface\n    iface=$(pct exec "$ctid" -- ip -o -4 addr show 2>/dev/null | awk '!/ lo / {print $2; exit}')\n    if [ -n "$iface" ]; then\n        ip=$(pct exec "$ctid" -- ip -4 addr show "$iface" 2>/dev/null | grep -oP 'inet \K[\d.]+' | head -1)\n    fi\n\n    if [ -n "$ip" ]; then\n        echo "$ip"\n        return 0\n    fi\n\n    # Fallback: try hostname -I inside container\n    ip=$(pct exec "$ctid" -- hostname -I 2>/dev/null | awk '{print $1}')\n\n    if [ -n "$ip" ]; then\n        echo "$ip"\n        return 0\n    fi\n\n    return 1\n}\n\n# Create new LXC container\ncreate_container() {\n    local ctid="$1"\n    local template="$2"\n    local storage="${3:-local-lvm}"\n    local disk_size="${4:-8}"\n    local memory="${5:-2048}"\n    local cores="${6:-2}"\n    local hostname="${7:-tailops-$ctid}"\n\n    log_info "Creating container $ctid from template $template..."\n\n    # Check if template exists\n    if ! pveam list "$storage" | grep -q "$template"; then\n        log_error "Template $template not found in storage $storage"\n        log_info "Available templates:"\n        pveam list "$storage"\n        return 1\n    fi\n\n    # Create container\n    if pct create "$ctid" "$storage:vztmpl/$template" \\n        --hostname "$hostname" \\n        --memory "$memory" \\n        --cores "$cores" \\n        --rootfs "$storage:$disk_size" \\n        --net0 name=eth0,bridge=vmbr0,ip=dhcp \\n        --features nesting=1,keyctl=1 \\n        --unprivileged 1 \\n        --start 1; then\n\n        log_success "Container $ctid created successfully"\n\n        # Wait for container to fully start\n        sleep 5\n\n        # Configure TUN device\n        local config_file="/etc/pve/lxc/${ctid}.conf"\n        echo "lxc.cgroup2.devices.allow: c 10:200 rwm" >> "$config_file"\n        echo "lxc.mount.entry: /dev/net dev/net none bind,create=dir" >> "$config_file"\n        echo "lxc.apparmor.profile: unconfined" >> "$config_file"\n\n        # Restart to apply changes\n        pct stop "$ctid"\n        sleep 2\n        pct start "$ctid"\n        sleep 3\n\n        log_success "Container $ctid fully configured and started"\n        return 0\n    else\n        log_error "Failed to create container $ctid"\n        return 1\n    fi\n}\n\n# List all containers\nlist_containers() {\n    pct list\n}\n\n# Get container configuration value\nget_container_config() {\n    local ctid="$1"\n    local key="$2"\n    local config_file="/etc/pve/lxc/${ctid}.conf"\n\n    grep "^${key}:" "$config_file" | cut -d':' -f2- | xargs\n}\n\n# Set container configuration value\nset_container_config() {\n    local ctid="$1"\n    local key="$2"\n    local value="$3"\n    local config_file="/etc/pve/lxc/${ctid}.conf"\n\n    if grep -q "^${key}:" "$config_file"; then\n        sed -i "s|^${key}:.*|${key}: ${value}|" "$config_file"\n    else\n        echo "${key}: ${value}" >> "$config_file"\n    fi\n}\n\n# Get container resource usage\nget_container_resources() {\n    local ctid="$1"\n\n    echo "=== Container $ctid Resource Usage ==="\n    pct status "$ctid"\n    echo\n    pct config "$ctid" | grep -E "^(memory|cores|rootfs)"\n    echo\n    if [ "$(get_container_status "$ctid")" = "running" ]; then\n        echo "Current usage:"\n        pct exec "$ctid" -- free -h 2>/dev/null || true\n        pct exec "$ctid" -- df -h / 2>/dev/null || true\n    fi\n}\n\n# Download template if not exists\ndownload_template() {\n    local template="$1"\n    local storage="${2:-local}"\n\n    log_info "Checking for template $template in storage $storage..."\n\n    if pveam list "$storage" | grep -q "$template"; then\n        log_success "Template $template already exists"\n        return 0\n    fi\n\n    log_info "Downloading template $template..."\n    if pveam download "$storage" "$template"; then\n        log_success "Template downloaded successfully"\n        return 0\n    else\n        log_error "Failed to download template"\n        return 1\n    fi\n}\n\n# Validate container meets minimum requirements\nvalidate_container_requirements() {\n    local ctid="$1"\n    local min_memory="${2:-1024}"\n    local min_disk="${3:-5}"\n    local issues=()\n\n    log_info "Validating container $ctid requirements..."\n\n    # Check memory\n    local memory\n    memory=$(get_container_config "$ctid" "memory")\n    if [ -n "$memory" ] && [ "$memory" -lt "$min_memory" ]; then\n        issues+=("Memory ($memory MB) is less than minimum ($min_memory MB)")\n    fi\n\n    # Check disk space\n    local rootfs\n    rootfs=$(get_container_config "$ctid" "rootfs")\n    if [ -n "$rootfs" ]; then\n        local disk_size_raw disk_size_num disk_size_unit disk_size_gb\n        disk_size_raw=$(echo "$rootfs" | grep -oP 'size=\K[0-9]+[KMGTP]?' || echo "0")\n        disk_size_num=$(echo "$disk_size_raw" | grep -oP '^\d+')\n        disk_size_unit=$(echo "$disk_size_raw" | grep -oP '[KMGTP]$')\n        # Default to G if no unit is specified\n        if [ -z "$disk_size_unit" ]; then\n            disk_size_unit="G"\n        fi\n        case "$disk_size_unit" in\n            K) disk_size_gb=$((disk_size_num / 1024 / 1024));;\n            M) disk_size_gb=$((disk_size_num / 1024));;\n            G) disk_size_gb=$((disk_size_num));;\n            T) disk_size_gb=$((disk_size_num * 1024));;\n            P) disk_size_gb=$((disk_size_num * 1024 * 1024));;\n            *) disk_size_gb=$((disk_size_num));; # fallback, treat as GB\n        esac\n        if [ "$disk_size_gb" -gt 0 ] && [ "$disk_size_gb" -lt "$min_disk" ]; then\n            issues+=("Disk space ($disk_size_gb GB) is less than minimum ($min_disk GB)")\n        fi\n    fi\n\n    if [ ${#issues[@]} -gt 0 ]; then\n        log_warning "Container $ctid resource issues:"\n        for issue in "${issues[@]}"; do\n            log_warning "  - $issue"\n        done\n        return 1\n    else\n        log_success "Container $ctid meets minimum requirements"\n        return 0\n    fi\n}\n\nexport -f check_proxmox_host\nexport -f container_exists\nexport -f get_container_status\nexport -f ensure_container_running\nexport -f stop_container\nexport -f check_container_features\nexport -f fix_container_features\nexport -f exec_in_container\nexport -f copy_to_container\nexport -f get_container_ip\nexport -f create_container\nexport -f list_containers\nexport -f get_container_config\nexport -f set_container_config\nexport -f get_container_resources\nexport -f download_template\nexport -f validate_container_requirements\n
