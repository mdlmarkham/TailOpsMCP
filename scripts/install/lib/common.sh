#!/usr/bin/env bash\n# Common utility functions for TailOpsMCP installation\n# Copyright (c) 2024 TailOpsMCP Contributors\n# License: MIT\n\n# Color codes\nRED='\033[0;31m'\nGREEN='\033[0;32m'\nYELLOW='\033[1;33m'\nBLUE='\033[0;36m'\nNC='\033[0m' # No Color\n\n# Installation state tracking\nINSTALL_STATE="/tmp/systemmanager-install-state-$$"\nINSTALL_LOG="/tmp/systemmanager-install-$$.log"\n\n# Default configuration\nDEFAULT_INSTALL_DIR="/opt/systemmanager"\nDEFAULT_PORT=8080\nDEFAULT_DATA_DIR="/var/lib/systemmanager"\n\n#######################################\n# Logging Functions\n#######################################\n\nfunction msg_info() {\n    echo -e "${BLUE}[INFO]${NC} $1" | tee -a "$INSTALL_LOG"\n}\n\nfunction msg_ok() {\n    echo -e "${GREEN}[✓]${NC} $1" | tee -a "$INSTALL_LOG"\n}\n\nfunction msg_warn() {\n    echo -e "${YELLOW}[⚠]${NC} $1" | tee -a "$INSTALL_LOG"\n}\n\nfunction msg_error() {\n    echo -e "${RED}[✗]${NC} $1" | tee -a "$INSTALL_LOG"\n}\n\n#######################################\n# State Tracking Functions\n#######################################\n\nfunction track_step() {\n    echo "$1:$(date +%s)" >> "$INSTALL_STATE"\n}\n\nfunction has_step() {\n    grep -q "^$1:" "$INSTALL_STATE" 2>/dev/null\n}\n\nfunction init_state() {\n    > "$INSTALL_STATE"\n    > "$INSTALL_LOG"\n    msg_info "Installation started at $(date)"\n    msg_info "Log file: $INSTALL_LOG"\n}\n\nfunction cleanup_state() {\n    if [ -f "$INSTALL_STATE" ]; then\n        rm -f "$INSTALL_STATE"\n    fi\n}\n\n#######################################\n# Error Handling & Rollback\n#######################################\n\nfunction rollback() {\n    local exit_code=$?\n\n    msg_error "Installation failed with exit code $exit_code"\n    msg_info "Rolling back changes..."\n\n    # Stop and remove service if created\n    if has_step "service_created"; then\n        msg_info "Removing systemd service..."\n        systemctl stop systemmanager-mcp 2>/dev/null || true\n        systemctl disable systemmanager-mcp 2>/dev/null || true\n        rm -f /etc/systemd/system/systemmanager-mcp.service\n        systemctl daemon-reload\n    fi\n\n    # Remove user if created\n    if has_step "user_created"; then\n        msg_info "Removing systemmanager user..."\n        userdel systemmanager 2>/dev/null || true\n        # Only remove group if it's now empty\n        if getent group systemmanager >/dev/null 2>&1; then\n            groupdel systemmanager 2>/dev/null || true\n        fi\n    fi\n\n    # Handle installation directory\n    if has_step "files_created"; then\n        if [ "$NON_INTERACTIVE" = "true" ]; then\n            msg_info "Removing installation directory: $INSTALL_DIR"\n            rm -rf "$INSTALL_DIR"\n        else\n            read -p "Remove installation directory ($INSTALL_DIR)? [y/N]: " remove_choice\n            if [[ $remove_choice =~ ^[Yy]$ ]]; then\n                rm -rf "$INSTALL_DIR"\n                msg_ok "Installation directory removed"\n            else\n                msg_info "Installation directory preserved at $INSTALL_DIR"\n            fi\n        fi\n    fi\n\n    cleanup_state\n    msg_error "Rollback complete. Check log: $INSTALL_LOG"\n    exit 1\n}\n\nfunction setup_error_handling() {\n    set -eE  # Exit on error, inherit ERR trap\n    trap rollback ERR\n}\n\n#######################################\n# Version Management\n#######################################\n\nfunction save_version() {\n    local version="${1:-unknown}"\n    echo "$version" > "$INSTALL_DIR/.version"\n    echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "$INSTALL_DIR/.install_date"\n}\n\nfunction get_installed_version() {\n    if [ -f "$INSTALL_DIR/.version" ]; then\n        cat "$INSTALL_DIR/.version"\n    else\n        echo "unknown"\n    fi\n}\n\nfunction detect_existing_installation() {\n    if [ -d "$INSTALL_DIR" ]; then\n        CURRENT_VERSION=$(get_installed_version)\n        msg_warn "Existing installation detected"\n        msg_info "  Location: $INSTALL_DIR"\n        msg_info "  Version: $CURRENT_VERSION"\n\n        if [ -f "$INSTALL_DIR/.install_date" ]; then\n            msg_info "  Installed: $(cat "$INSTALL_DIR/.install_date")"\n        fi\n\n        return 0  # Installation exists\n    else\n        return 1  # No installation\n    fi\n}\n\n#######################################\n# Backup Functions\n#######################################\n\nfunction backup_existing_config() {\n    if [ -f "$INSTALL_DIR/.env" ]; then\n        local backup_file="$INSTALL_DIR/.env.backup-$(date +%s)"\n        msg_info "Backing up existing configuration..."\n        cp "$INSTALL_DIR/.env" "$backup_file"\n        chmod 600 "$backup_file"\n        msg_ok "Configuration backed up to: $backup_file"\n        track_step "config_backed_up"\n    fi\n}\n\nfunction restore_config_from_backup() {\n    local latest_backup=$(ls -t "$INSTALL_DIR"/.env.backup-* 2>/dev/null | head -1)\n    if [ -n "$latest_backup" ]; then\n        msg_info "Restoring configuration from backup..."\n        cp "$latest_backup" "$INSTALL_DIR/.env"\n        chmod 600 "$INSTALL_DIR/.env"\n        msg_ok "Configuration restored"\n    fi\n}\n\n#######################################\n# User & Permissions\n#######################################\n\nfunction create_service_user() {\n    msg_info "Creating dedicated service user"\n\n    if id -u systemmanager >/dev/null 2>&1; then\n        msg_ok "systemmanager user already exists"\n    else\n        useradd --system --no-create-home --shell /usr/sbin/nologin systemmanager\n        msg_ok "Created systemmanager user"\n        track_step "user_created"\n    fi\n\n    # Add to docker group if docker is installed\n    if command -v docker &>/dev/null; then\n        usermod -aG docker systemmanager 2>/dev/null || true\n        msg_ok "Added systemmanager to docker group"\n    fi\n}\n\nfunction setup_permissions() {\n    local install_dir="${1:-$INSTALL_DIR}"\n    local data_dir="${2:-$DEFAULT_DATA_DIR}"\n\n    msg_info "Setting up permissions"\n\n    # Create and set ownership of data directory\n    mkdir -p "$data_dir"\n    chown -R systemmanager:systemmanager "$data_dir"\n    chmod 755 "$data_dir"\n\n    # Set ownership of installation directory\n    chown -R systemmanager:systemmanager "$install_dir"\n\n    # Secure sensitive files\n    if [ -f "$install_dir/.env" ]; then\n        chmod 600 "$install_dir/.env"\n        chown systemmanager:systemmanager "$install_dir/.env"\n    fi\n\n    msg_ok "Permissions configured"\n}\n\n#######################################\n# Network & Connectivity\n#######################################\n\nfunction check_port_available() {\n    local port="${1:-$DEFAULT_PORT}"\n\n    if command -v lsof >/dev/null 2>&1; then\n        if lsof -Pi ":$port" -sTCP:LISTEN -t >/dev/null 2>&1; then\n            return 1  # Port in use\n        fi\n    elif command -v ss >/dev/null 2>&1; then\n        if ss -tlnp | grep -q ":$port "; then\n            return 1  # Port in use\n        fi\n    elif command -v netstat >/dev/null 2>&1; then\n        if netstat -tlnp 2>/dev/null | grep -q ":$port "; then\n            return 1  # Port in use\n        fi\n    fi\n\n    return 0  # Port available\n}\n\nfunction test_network_connectivity() {\n    local test_hosts=("github.com" "raw.githubusercontent.com" "pypi.org")\n    local failures=0\n\n    for host in "${test_hosts[@]}"; do\n        if ! ping -c 1 -W 2 "$host" &>/dev/null; then\n            msg_warn "Cannot reach $host"\n            ((failures++))\n        fi\n    done\n\n    if [ $failures -eq ${#test_hosts[@]} ]; then\n        msg_error "No internet connectivity detected"\n        return 1\n    elif [ $failures -gt 0 ]; then\n        msg_warn "Partial connectivity issues detected"\n    fi\n\n    return 0\n}\n\n#######################################\n# Package Management\n#######################################\n\nfunction detect_package_manager() {\n    if command -v apt-get &>/dev/null; then\n        PKG_MANAGER="apt"\n        PKG_UPDATE="apt-get update"\n        PKG_INSTALL="apt-get install -y"\n        PKG_UPGRADE="apt-get upgrade -y"\n    elif command -v dnf &>/dev/null; then\n        PKG_MANAGER="dnf"\n        PKG_UPDATE="dnf check-update || true"\n        PKG_INSTALL="dnf install -y"\n        PKG_UPGRADE="dnf upgrade -y"\n    elif command -v yum &>/dev/null; then\n        PKG_MANAGER="yum"\n        PKG_UPDATE="yum check-update || true"\n        PKG_INSTALL="yum install -y"\n        PKG_UPGRADE="yum upgrade -y"\n    else\n        msg_error "No supported package manager found (apt, dnf, yum)"\n        return 1\n    fi\n\n    export PKG_MANAGER PKG_UPDATE PKG_INSTALL PKG_UPGRADE\n    return 0\n}\n\nfunction install_base_packages() {\n    msg_info "Installing base dependencies"\n\n    detect_package_manager || return 1\n\n    # Update package lists\n    $STD $PKG_UPDATE\n\n    # Common packages across all distros\n    local packages=(\n        curl\n        wget\n        git\n        ca-certificates\n        gnupg\n        lsof\n    )\n\n    # Add distro-specific packages\n    case $PKG_MANAGER in\n        apt)\n            packages+=(sudo gpg)\n            ;;\n        dnf|yum)\n            packages+=(sudo which)\n            ;;\n    esac\n\n    $STD $PKG_INSTALL "${packages[@]}"\n\n    msg_ok "Installed base dependencies"\n    track_step "base_packages_installed"\n}\n\n#######################################\n# Python Management\n#######################################\n\nfunction detect_python() {\n    # Try to find Python 3.11+\n    for py_cmd in python3.12 python3.11 python3; do\n        if command -v "$py_cmd" &>/dev/null; then\n            PYTHON_CMD="$py_cmd"\n            PYTHON_VERSION=$($py_cmd --version 2>&1 | awk '{print $2}')\n\n            # Check if version is >= 3.11\n            local major=$(echo "$PYTHON_VERSION" | cut -d. -f1)\n            local minor=$(echo "$PYTHON_VERSION" | cut -d. -f2)\n\n            if [ "$major" -ge 3 ] && [ "$minor" -ge 11 ]; then\n                msg_ok "Found compatible Python: $PYTHON_CMD ($PYTHON_VERSION)"\n                export PYTHON_CMD PYTHON_VERSION\n                return 0\n            fi\n        fi\n    done\n\n    msg_error "Python 3.11+ not found"\n    return 1\n}\n\nfunction install_python() {\n    msg_info "Installing Python"\n\n    detect_package_manager || return 1\n\n    case $PKG_MANAGER in\n        apt)\n            $STD $PKG_INSTALL \\n                python3 \\n                python3-pip \\n                python3-venv \\n                python3-dev \\n                build-essential\n            ;;\n        dnf|yum)\n            $STD $PKG_INSTALL \\n                python3 \\n                python3-pip \\n                python3-devel \\n                gcc \\n                gcc-c++ \\n                make\n            ;;\n    esac\n\n    # Verify installation\n    if ! detect_python; then\n        msg_error "Python installation failed"\n        return 1\n    fi\n\n    msg_ok "Installed Python $PYTHON_VERSION"\n    track_step "python_installed"\n}\n\n#######################################\n# Docker Management\n#######################################\n\nfunction install_docker() {\n    if command -v docker &>/dev/null; then\n        msg_ok "Docker already installed: $(docker --version)"\n        return 0\n    fi\n\n    if [ "$SKIP_DOCKER" = "true" ]; then\n        msg_info "Skipping Docker installation (SKIP_DOCKER=true)"\n        return 0\n    fi\n\n    msg_info "Installing Docker"\n\n    # Download Docker install script\n    local docker_script="/tmp/docker-install-$$.sh"\n    curl -fsSL https://get.docker.com -o "$docker_script"\n\n    # Optional: Review in interactive mode\n    if [ "$NON_INTERACTIVE" != "true" ]; then\n        echo ""\n        msg_warn "About to run Docker installation script"\n        read -p "Review script before installation? [y/N]: " review_choice\n        if [[ $review_choice =~ ^[Yy]$ ]]; then\n            ${PAGER:-less} "$docker_script"\n            read -p "Proceed with Docker installation? [y/N]: " proceed_choice\n            if [[ ! $proceed_choice =~ ^[Yy]$ ]]; then\n                rm "$docker_script"\n                msg_error "Docker installation cancelled"\n                return 1\n            fi\n        fi\n    fi\n\n    # Run Docker install script\n    $STD bash "$docker_script"\n    rm "$docker_script"\n\n    # Enable and start Docker\n    systemctl enable docker 2>/dev/null || true\n    systemctl start docker 2>/dev/null || true\n\n    # Wait for Docker to be ready\n    local retries=0\n    while ! docker info &>/dev/null && [ $retries -lt 10 ]; do\n        sleep 1\n        ((retries++))\n    done\n\n    if docker info &>/dev/null; then\n        msg_ok "Installed Docker: $(docker --version)"\n        track_step "docker_installed"\n        return 0\n    else\n        msg_error "Docker installation succeeded but service not ready"\n        return 1\n    fi\n}\n\n#######################################\n# Service Management\n#######################################\n\nfunction create_systemd_service() {\n    local install_dir="${1:-$INSTALL_DIR}"\n    local port="${2:-$DEFAULT_PORT}"\n    local data_dir="${3:-$DEFAULT_DATA_DIR}"\n\n    msg_info "Creating systemd service"\n\n    cat > /etc/systemd/system/systemmanager-mcp.service << EOF\n[Unit]\nDescription=TailOpsMCP - Secure MCP control surface for Tailscale homelabs\nDocumentation=https://github.com/mdlmarkham/TailOpsMCP\nAfter=network-online.target docker.service\nWants=network-online.target\n\n[Service]\nType=simple\nUser=systemmanager\nGroup=systemmanager\nWorkingDirectory=$install_dir\nEnvironment="PATH=$install_dir/venv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n\n# Load secrets from protected environment file\nEnvironmentFile=$install_dir/.env\n\nExecStart=$install_dir/venv/bin/python -m src.mcp_server\nRestart=on-failure\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n# Security hardening\nPrivateTmp=yes\nProtectSystem=strict\nProtectHome=yes\nReadWritePaths=$data_dir\nNoNewPrivileges=true\nProtectKernelTunables=yes\nProtectControlGroups=yes\nRestrictRealtime=yes\nRestrictNamespaces=yes\nLockPersonality=yes\nMemoryDenyWriteExecute=yes\nRestrictAddressFamilies=AF_UNIX AF_INET AF_INET6\nSystemCallFilter=@system-service\nSystemCallErrorNumber=EPERM\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n    systemctl daemon-reload\n    systemctl enable systemmanager-mcp.service\n\n    msg_ok "Created systemd service"\n    track_step "service_created"\n}\n\nfunction start_service() {\n    msg_info "Starting SystemManager MCP Server"\n\n    systemctl start systemmanager-mcp.service\n\n    # Wait for service to start\n    sleep 3\n\n    if systemctl is-active --quiet systemmanager-mcp.service; then\n        msg_ok "SystemManager MCP Server started successfully"\n        return 0\n    else\n        msg_error "Failed to start service"\n        msg_error "Check logs: journalctl -u systemmanager-mcp -n 50"\n        return 1\n    fi\n}\n\n#######################################\n# Git & Repository Management\n#######################################\n\nfunction clone_repository() {\n    local install_dir="${1:-$INSTALL_DIR}"\n    local repo_url="${2:-https://github.com/mdlmarkham/TailOpsMCP.git}"\n    local branch="${3:-main}"\n\n    msg_info "Cloning TailOpsMCP repository"\n\n    mkdir -p "$install_dir"\n    cd "$install_dir"\n\n    # Check if already a git repository\n    if [ -d ".git" ]; then\n        msg_info "Repository already exists, updating..."\n        $STD git fetch origin\n        $STD git checkout "$branch"\n        $STD git pull origin "$branch"\n    else\n        $STD git clone "$repo_url" .\n        $STD git checkout "$branch"\n    fi\n\n    # Get current version/commit\n    local version=$(git describe --tags --always 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")\n    save_version "$version"\n\n    msg_ok "Repository cloned/updated: $version"\n    track_step "repo_cloned"\n}\n\n#######################################\n# Python Virtual Environment\n#######################################\n\nfunction setup_python_venv() {\n    local install_dir="${1:-$INSTALL_DIR}"\n\n    msg_info "Setting up Python virtual environment"\n\n    cd "$install_dir"\n\n    # Create venv if it doesn't exist\n    if [ ! -d "venv" ]; then\n        $STD $PYTHON_CMD -m venv venv\n        msg_ok "Created virtual environment"\n    else\n        msg_ok "Virtual environment already exists"\n    fi\n\n    # Activate and upgrade pip\n    source venv/bin/activate\n    $STD pip install --upgrade pip setuptools wheel\n\n    # Install requirements\n    if [ -f "requirements.txt" ]; then\n        $STD pip install -r requirements.txt\n        msg_ok "Installed Python dependencies"\n    else\n        msg_warn "requirements.txt not found"\n    fi\n\n    deactivate\n    track_step "venv_setup"\n}\n\n#######################################\n# Utility Functions\n#######################################\n\nfunction confirm_action() {\n    local prompt="$1"\n    local default="${2:-N}"\n\n    if [ "$NON_INTERACTIVE" = "true" ]; then\n        return 0  # Always proceed in non-interactive mode\n    fi\n\n    local response\n    read -p "$prompt [$default]: " response\n    response=${response:-$default}\n\n    if [[ $response =~ ^[Yy]$ ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\nfunction print_separator() {\n    echo ""\n    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"\n    echo ""\n}\n\nfunction print_banner() {\n    clear\n    cat << "EOF"\n   _____           __                 __  ___\n  / ___/__  ______/ /____  ____ ___  /  |/  /___ _____  ____ _____ ____  _____\n  \__ \/ / / / ___/ __/ _ \/ __ `__ \/ /|_/ / __ `/ __ \/ __ `/ __ `/ _ \/ ___/\n ___/ / /_/ (__  ) /_/  __/ / / / / / /  / / /_/ / / / / /_/ / /_/ /  __/ /\n/____/\__, /____/\__/\___/_/ /_/ /_/_/  /_/\__,_/_/ /_/\__,_/\__, /\___/_/\n     /____/                                                 /____/\n\nTailOpsMCP - Secure MCP control surface for Tailscale homelabs\nEOF\n    echo ""\n}\n\n# Initialize variables if not set\n: "${STD:=}"\n: "${NON_INTERACTIVE:=false}"\n: "${SKIP_DOCKER:=false}"\n: "${INSTALL_DIR:=$DEFAULT_INSTALL_DIR}"\n: "${SYSTEMMANAGER_PORT:=$DEFAULT_PORT}"\n\n# Export all functions for use in other scripts\nexport -f msg_info msg_ok msg_warn msg_error\nexport -f track_step has_step init_state cleanup_state\nexport -f rollback setup_error_handling\nexport -f save_version get_installed_version detect_existing_installation\nexport -f backup_existing_config restore_config_from_backup\nexport -f create_service_user setup_permissions\nexport -f check_port_available test_network_connectivity\nexport -f detect_package_manager install_base_packages\nexport -f detect_python install_python\nexport -f install_docker\nexport -f create_systemd_service start_service\nexport -f clone_repository setup_python_venv\nexport -f confirm_action print_separator print_banner\n
