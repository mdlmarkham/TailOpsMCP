#!/usr/bin/env bash\n# Pre-flight checks for TailOpsMCP installation\n# Copyright (c) 2024 TailOpsMCP Contributors\n# License: MIT\n\n#######################################\n# Resource Requirements\n#######################################\n\n# Minimum requirements\nMIN_MEMORY_MB=1024\nMIN_DISK_GB=5\nMIN_CPU_CORES=1\n\n# Recommended requirements\nREC_MEMORY_MB=2048\nREC_DISK_GB=10\nREC_CPU_CORES=2\n\n#######################################\n# Check System Resources\n#######################################\n\nfunction check_memory() {\n    local errors=0\n\n    if [ "$TOTAL_MEM" -lt "$MIN_MEMORY_MB" ]; then\n        msg_error "Insufficient memory: ${TOTAL_MEM}MB (minimum: ${MIN_MEMORY_MB}MB)"\n        ((errors++))\n    elif [ "$TOTAL_MEM" -lt "$REC_MEMORY_MB" ]; then\n        msg_warn "Low memory: ${TOTAL_MEM}MB (recommended: ${REC_MEMORY_MB}MB)"\n    else\n        msg_ok "Memory check passed: ${TOTAL_MEM}MB"\n    fi\n\n    return $errors\n}\n\nfunction check_disk_space() {\n    local errors=0\n\n    if [ "$AVAIL_DISK" -lt "$MIN_DISK_GB" ]; then\n        msg_error "Insufficient disk space: ${AVAIL_DISK}GB (minimum: ${MIN_DISK_GB}GB)"\n        ((errors++))\n    elif [ "$AVAIL_DISK" -lt "$REC_DISK_GB" ]; then\n        msg_warn "Low disk space: ${AVAIL_DISK}GB (recommended: ${REC_DISK_GB}GB)"\n    else\n        msg_ok "Disk space check passed: ${AVAIL_DISK}GB available"\n    fi\n\n    return $errors\n}\n\nfunction check_cpu_cores() {\n    if [ "$CPU_CORES" -lt "$MIN_CPU_CORES" ]; then\n        msg_warn "Low CPU cores: $CPU_CORES (minimum: $MIN_CPU_CORES)"\n    elif [ "$CPU_CORES" -lt "$REC_CPU_CORES" ]; then\n        msg_info "CPU cores: $CPU_CORES (recommended: $REC_CPU_CORES)"\n    else\n        msg_ok "CPU cores check passed: $CPU_CORES"\n    fi\n\n    return 0\n}\n\n#######################################\n# Check Network Connectivity\n#######################################\n\nfunction check_internet_connectivity() {\n    local errors=0\n    local test_hosts=(\n        "github.com"\n        "raw.githubusercontent.com"\n        "pypi.org"\n    )\n\n    msg_info "Checking internet connectivity..."\n\n    for host in "${test_hosts[@]}"; do\n        if ping -c 1 -W 2 "$host" &>/dev/null; then\n            msg_ok "Can reach $host"\n        else\n            msg_error "Cannot reach $host"\n            ((errors++))\n        fi\n    done\n\n    if [ $errors -eq ${#test_hosts[@]} ]; then\n        msg_error "No internet connectivity detected"\n        msg_error "Installation requires internet access"\n        return 1\n    elif [ $errors -gt 0 ]; then\n        msg_warn "Partial connectivity issues detected ($errors/${#test_hosts[@]} hosts unreachable)"\n        return 0\n    else\n        msg_ok "Internet connectivity check passed"\n        return 0\n    fi\n}\n\nfunction check_dns_resolution() {\n    local errors=0\n\n    msg_info "Checking DNS resolution..."\n\n    if command -v nslookup &>/dev/null; then\n        if nslookup github.com &>/dev/null; then\n            msg_ok "DNS resolution working"\n        else\n            msg_error "DNS resolution failed"\n            ((errors++))\n        fi\n    elif command -v dig &>/dev/null; then\n        if dig github.com +short &>/dev/null; then\n            msg_ok "DNS resolution working"\n        else\n            msg_error "DNS resolution failed"\n            ((errors++))\n        fi\n    else\n        msg_warn "Cannot verify DNS (nslookup/dig not found)"\n    fi\n\n    return $errors\n}\n\n#######################################\n# Check Port Availability\n#######################################\n\nfunction check_port_availability() {\n    local port="${1:-$SYSTEMMANAGER_PORT}"\n    port="${port:-8080}"\n\n    msg_info "Checking if port $port is available..."\n\n    if check_port_available "$port"; then\n        msg_ok "Port $port is available"\n        return 0\n    else\n        msg_error "Port $port is already in use"\n\n        # Try to identify what's using the port\n        if command -v lsof &>/dev/null; then\n            local process_info=$(lsof -ti ":$port" 2>/dev/null)\n            if [ -n "$process_info" ]; then\n                msg_info "Process using port $port:"\n                lsof -i ":$port" | grep -v COMMAND | head -3 | while read line; do\n                    msg_info "  $line"\n                done\n            fi\n        fi\n\n        if [ "$NON_INTERACTIVE" = "true" ]; then\n            msg_error "Cannot proceed with port $port in use"\n            return 1\n        fi\n\n        if confirm_action "Use a different port?" "y"; then\n            read -p "Enter port number: " SYSTEMMANAGER_PORT\n            export SYSTEMMANAGER_PORT\n            # Recursive check with new port\n            check_port_availability "$SYSTEMMANAGER_PORT"\n            return $?\n        else\n            return 1\n        fi\n    fi\n}\n\n#######################################\n# Check Required Commands\n#######################################\n\nfunction check_required_commands() {\n    local errors=0\n    local required_cmds=(\n        "curl"\n        "wget"\n        "git"\n        "systemctl"\n    )\n\n    msg_info "Checking required commands..."\n\n    for cmd in "${required_cmds[@]}"; do\n        if command -v "$cmd" &>/dev/null; then\n            msg_ok "Found: $cmd"\n        else\n            msg_error "Missing required command: $cmd"\n            ((errors++))\n        fi\n    done\n\n    if [ $errors -gt 0 ]; then\n        msg_error "$errors required command(s) missing"\n        msg_info "These will be installed during setup"\n    fi\n\n    return 0  # Don't fail, we'll install them\n}\n\n#######################################\n# Check Systemd\n#######################################\n\nfunction check_systemd() {\n    msg_info "Checking systemd..."\n\n    if ! command -v systemctl &>/dev/null; then\n        msg_error "systemctl not found - systemd is required"\n        return 1\n    fi\n\n    if ! systemctl --version &>/dev/null; then\n        msg_error "systemd is not functioning properly"\n        return 1\n    fi\n\n    # Check if we can interact with systemd\n    if ! systemctl list-units &>/dev/null; then\n        msg_error "Cannot interact with systemd"\n        return 1\n    fi\n\n    msg_ok "systemd is available and working"\n    return 0\n}\n\n#######################################\n# Check Existing Installation\n#######################################\n\nfunction check_existing_installation() {\n    if detect_existing_installation; then\n        msg_warn "Existing installation found"\n\n        if [ "$FORCE_REINSTALL" = "true" ]; then\n            msg_info "FORCE_REINSTALL=true, will upgrade/reinstall"\n            return 0\n        fi\n\n        if [ "$NON_INTERACTIVE" = "true" ]; then\n            msg_error "Existing installation found and NON_INTERACTIVE=true"\n            msg_error "Set FORCE_REINSTALL=true to upgrade"\n            return 1\n        fi\n\n        echo ""\n        echo "Options:"\n        echo "  1) Upgrade existing installation"\n        echo "  2) Reinstall (preserve configuration)"\n        echo "  3) Abort"\n        echo ""\n        read -p "Select [1-3]: " choice\n\n        case $choice in\n            1)\n                UPGRADE_MODE=true\n                export UPGRADE_MODE\n                msg_info "Will upgrade existing installation"\n                return 0\n                ;;\n            2)\n                REINSTALL_MODE=true\n                export REINSTALL_MODE\n                msg_info "Will reinstall (configuration preserved)"\n                return 0\n                ;;\n            3|*)\n                msg_error "Installation aborted by user"\n                return 1\n                ;;\n        esac\n    fi\n\n    return 0\n}\n\n#######################################\n# Check User Privileges\n#######################################\n\nfunction check_root_privileges() {\n    if [ "$EUID" -ne 0 ]; then\n        msg_error "This script must be run as root"\n        msg_info "Please run: sudo $0"\n        return 1\n    fi\n\n    msg_ok "Running with root privileges"\n    return 0\n}\n\n#######################################\n# Check for Conflicting Services\n#######################################\n\nfunction check_conflicting_services() {\n    local conflicts=0\n\n    msg_info "Checking for conflicting services..."\n\n    # Check if systemmanager-mcp service already exists but is from different installation\n    if systemctl list-unit-files | grep -q "systemmanager-mcp.service"; then\n        if [ ! -d "$INSTALL_DIR" ]; then\n            msg_warn "systemmanager-mcp service exists but installation directory not found"\n            msg_warn "May need manual cleanup"\n            ((conflicts++))\n        fi\n    fi\n\n    if [ $conflicts -gt 0 ]; then\n        msg_warn "$conflicts potential conflict(s) found"\n        if [ "$NON_INTERACTIVE" != "true" ]; then\n            if ! confirm_action "Continue anyway?" "y"; then\n                return 1\n            fi\n        fi\n    fi\n\n    return 0\n}\n\n#######################################\n# Security Checks\n#######################################\n\nfunction check_security_requirements() {\n    msg_info "Checking security requirements..."\n\n    # Check if SELinux is enforcing (might cause issues)\n    if command -v getenforce &>/dev/null; then\n        SELINUX_STATUS=$(getenforce 2>/dev/null || echo "Unknown")\n        if [ "$SELINUX_STATUS" = "Enforcing" ]; then\n            msg_warn "SELinux is enforcing - may require additional configuration"\n            msg_info "Consider running: setenforce 0"\n        fi\n    fi\n\n    # Check if AppArmor is active\n    if command -v aa-status &>/dev/null; then\n        if aa-status --enabled 2>/dev/null; then\n            msg_info "AppArmor is active - service will run in confined mode"\n        fi\n    fi\n\n    # Check if firewall is active\n    if command -v ufw &>/dev/null; then\n        if ufw status 2>/dev/null | grep -q "Status: active"; then\n            msg_warn "UFW firewall is active"\n            msg_info "You may need to allow port ${SYSTEMMANAGER_PORT:-8080}"\n            msg_info "Run: ufw allow ${SYSTEMMANAGER_PORT:-8080}/tcp"\n        fi\n    elif command -v firewall-cmd &>/dev/null; then\n        if firewall-cmd --state 2>/dev/null | grep -q "running"; then\n            msg_warn "firewalld is active"\n            msg_info "You may need to allow port ${SYSTEMMANAGER_PORT:-8080}"\n            msg_info "Run: firewall-cmd --permanent --add-port=${SYSTEMMANAGER_PORT:-8080}/tcp && firewall-cmd --reload"\n        fi\n    fi\n\n    return 0\n}\n\n#######################################\n# Platform-Specific Checks\n#######################################\n\nfunction check_lxc_requirements() {\n    if [ "$PLATFORM" = "lxc" ]; then\n        msg_info "Checking LXC-specific requirements..."\n\n        # Check for privileged mode if installing Docker\n        if [ "$SKIP_DOCKER" != "true" ]; then\n            if [ ! -d /sys/fs/cgroup/systemd ]; then\n                msg_warn "Systemd cgroup not detected"\n                msg_warn "Docker may not work properly"\n                msg_info "Enable nesting in LXC config: features: nesting=1"\n            fi\n        fi\n\n        # Check TUN device for Tailscale\n        if [ ! -c /dev/net/tun ] && [ "$TAILSCALE_INSTALLED" != "true" ]; then\n            msg_warn "/dev/net/tun not available"\n            msg_info "For Tailscale support, add to LXC config:"\n            msg_info "  lxc.cgroup2.devices.allow: c 10:200 rwm"\n            msg_info "  lxc.mount.entry: /dev/net/tun dev/net/tun none bind,create=file"\n        fi\n    fi\n}\n\nfunction check_cloud_requirements() {\n    case "$CLOUD_PROVIDER" in\n        aws)\n            msg_info "AWS EC2 detected - checking cloud-specific requirements..."\n            # Check security groups (can't do from inside, just inform)\n            msg_info "Ensure security group allows inbound on port ${SYSTEMMANAGER_PORT:-8080}"\n            msg_info "Or use Tailscale for secure access"\n            ;;\n        gcp|azure|digitalocean)\n            msg_info "$CLOUD_PROVIDER detected - ensure firewall rules allow access"\n            ;;\n    esac\n}\n\n#######################################\n# Main Preflight Function\n#######################################\n\nfunction run_preflight_checks() {\n    local errors=0\n\n    msg_info "Running pre-flight checks..."\n    print_separator\n\n    # Critical checks (must pass)\n    check_root_privileges || ((errors++))\n    check_systemd || ((errors++))\n\n    # Resource checks\n    check_memory || ((errors++))\n    check_disk_space || ((errors++))\n    check_cpu_cores\n\n    # Network checks\n    check_internet_connectivity || ((errors++))\n    check_dns_resolution\n\n    # Port check\n    check_port_availability || ((errors++))\n\n    # Installation checks\n    check_existing_installation || ((errors++))\n    check_conflicting_services || ((errors++))\n\n    # Security checks\n    check_security_requirements\n\n    # Platform-specific checks\n    check_lxc_requirements\n    check_cloud_requirements\n\n    # Command checks (informational)\n    check_required_commands\n\n    print_separator\n\n    if [ $errors -gt 0 ]; then\n        msg_error "$errors critical pre-flight check(s) failed"\n        msg_error "Cannot proceed with installation"\n        return 1\n    else\n        msg_ok "All pre-flight checks passed"\n        return 0\n    fi\n}\n\n#######################################\n# Quick Preflight (for upgrades)\n#######################################\n\nfunction run_quick_preflight() {\n    local errors=0\n\n    msg_info "Running quick pre-flight checks..."\n\n    check_root_privileges || ((errors++))\n    check_internet_connectivity || ((errors++))\n    check_disk_space || ((errors++))\n\n    if [ $errors -gt 0 ]; then\n        msg_error "$errors check(s) failed"\n        return 1\n    else\n        msg_ok "Quick pre-flight checks passed"\n        return 0\n    fi\n}\n\n# Export functions\nexport -f check_memory check_disk_space check_cpu_cores\nexport -f check_internet_connectivity check_dns_resolution\nexport -f check_port_availability check_required_commands\nexport -f check_systemd check_existing_installation\nexport -f check_root_privileges check_conflicting_services\nexport -f check_security_requirements\nexport -f check_lxc_requirements check_cloud_requirements\nexport -f run_preflight_checks run_quick_preflight\n
