#!/bin/bash\nset -euo pipefail\n\n# TailOpsMCP Multi-Container Installation Script\n# Deploy TailOpsMCP from a Proxmox host to multiple LXC containers\n#\n# Usage:\n#   ./install-proxmox-multi.sh [--config /path/to/config.conf] [--containers 101,102,103]\n#\n# Examples:\n#   # Use configuration file\n#   ./install-proxmox-multi.sh --config /root/my-deployment.conf\n#\n#   # Quick deploy to specific containers (interactive)\n#   ./install-proxmox-multi.sh --containers 101,102,103\n#\n#   # Create new containers and deploy\n#   ./install-proxmox-multi.sh --create --containers 201,202,203\n\nSCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"\nPROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"\n\n# Source library functions\n# shellcheck source=scripts/install/lib/common.sh\nsource "$SCRIPT_DIR/lib/common.sh"\n# shellcheck source=scripts/install/lib/proxmox-api.sh\nsource "$SCRIPT_DIR/lib/proxmox-api.sh"\n# shellcheck source=scripts/install/lib/platform-detect.sh\nsource "$SCRIPT_DIR/lib/platform-detect.sh"\n\n# Default configuration\nCONFIG_FILE=""\nCONTAINERS=""\nCONTAINER_NAMES=""\nCREATE_CONTAINERS=false\nCONTAINER_TEMPLATE="debian-12-standard"\nCONTAINER_STORAGE="local-lvm"\nCONTAINER_DISK_SIZE="8G"\nCONTAINER_MEMORY=2048\nCONTAINER_CORES=2\nCONTAINER_NETWORK_BRIDGE="vmbr0"\nCONTAINER_IP_MODE="dhcp"\nHOSTNAME_PREFIX="tailops"\n\nINSTALL_MODE="standalone"\nSYSTEMMANAGER_INSTALL_DIR="/opt/systemmanager"\nSYSTEMMANAGER_REPO="${SYSTEMMANAGER_REPO:-https://github.com/mdlmarkham/TailOpsMCP.git}"\nSYSTEMMANAGER_REPO_BRANCH="${SYSTEMMANAGER_REPO_BRANCH:-main}"\nSKIP_DOCKER=false\n\nAUTH_MODE="oidc"\nSYSTEMMANAGER_SHARED_SECRET=""\nTSIDP_URL=""\nTSIDP_CLIENT_ID=""\nTSIDP_CLIENT_SECRET=""\n\nDEPLOYMENT_STRATEGY="sequential"\nMAX_PARALLEL=3\nAUTO_FIX_FEATURES=true\nCONTINUE_ON_FAILURE=true\nRUN_VALIDATION=true\nFORCE_REINSTALL=false\nBACKUP_BEFORE_INSTALL=true\n\nLOG_LEVEL="info"\nLOG_DIR="/var/log/systemmanager-install"\nCONTAINER_START_TIMEOUT=30\nINSTALL_TIMEOUT=600\nNON_INTERACTIVE=false\n\n# Tarball exclusions for deployment\nTARBALL_EXCLUDES=(\n    '--exclude=.git'\n    '--exclude=*.pyc'\n    '--exclude=__pycache__'\n    '--exclude=venv'\n    '--exclude=.env'\n)\n\n# Deployment tracking\ndeclare -A DEPLOYMENT_STATUS\ndeclare -A DEPLOYMENT_IPS\ndeclare -A DEPLOYMENT_ERRORS\n\n# Parse command line arguments\nparse_args() {\n    while [[ $# -gt 0 ]]; do\n        case $1 in\n            --config)\n                CONFIG_FILE="$2"\n                shift 2\n                ;;\n            --containers)\n                CONTAINERS="$2"\n                shift 2\n                ;;\n            --create)\n                CREATE_CONTAINERS=true\n                shift\n                ;;\n            --auth)\n                AUTH_MODE="$2"\n                shift 2\n                ;;\n            --parallel)\n                DEPLOYMENT_STRATEGY="parallel"\n                shift\n                ;;\n            --sequential)\n                DEPLOYMENT_STRATEGY="sequential"\n                shift\n                ;;\n            --help|-h)\n                show_help\n                exit 0\n                ;;\n            *)\n                log_error "Unknown option: $1"\n                show_help\n                exit 1\n                ;;\n        esac\n    done\n}\n\nshow_help() {\n    cat << EOF\nTailOpsMCP Multi-Container Installation Script\n\nDeploy TailOpsMCP from a Proxmox host to multiple LXC containers.\n\nUsage:\n    $0 [OPTIONS]\n\nOptions:\n    --config FILE           Path to configuration file\n    --containers IDs        Comma-separated container IDs (e.g., 101,102,103)\n    --create                Create new containers (requires --containers)\n    --auth MODE             Authentication mode: oidc, token, none\n    --parallel              Deploy to all containers in parallel\n    --sequential            Deploy to containers one at a time (default)\n    -h, --help              Show this help message\n\nExamples:\n    # Deploy to existing containers using config file\n    $0 --config /root/deployment.conf\n\n    # Quick deploy to specific containers\n    $0 --containers 101,102,103 --auth token\n\n    # Create 3 new containers and deploy\n    $0 --create --containers 201,202,203\n\n    # Parallel deployment for speed\n    $0 --config deployment.conf --parallel\n\nConfiguration:\n    Create a config file from the template:\n    cp $SCRIPT_DIR/templates/proxmox-multi.conf /root/my-deployment.conf\n\n    Edit the file and run:\n    $0 --config /root/my-deployment.conf\n\nDocumentation:\n    See docs/installation/proxmox-multi-container.md for detailed documentation\nEOF\n}\n\n# Load configuration file\nload_config() {\n    if [ -n "$CONFIG_FILE" ]; then\n        if [ ! -f "$CONFIG_FILE" ]; then\n            log_error "Configuration file not found: $CONFIG_FILE"\n            exit 1\n        fi\n\n        log_info "Loading configuration from $CONFIG_FILE"\n        # shellcheck source=/dev/null\n        source "$CONFIG_FILE"\n        log_success "Configuration loaded"\n    fi\n}\n\n# Validate configuration\nvalidate_config() {\n    log_section "Validating Configuration"\n\n    if [ -z "$CONTAINERS" ] && [ -z "$CONTAINER_NAMES" ]; then\n        log_error "No containers specified. Use --containers or set CONTAINERS in config file"\n        return 1\n    fi\n\n    if [ "$CREATE_CONTAINERS" = true ] && [ -z "$CONTAINER_TEMPLATE" ]; then\n        log_error "CREATE_CONTAINERS is true but no template specified"\n        return 1\n    fi\n\n    if [ "$AUTH_MODE" = "oidc" ]; then\n        if [ -z "$TSIDP_URL" ] || [ -z "$TSIDP_CLIENT_ID" ] || [ -z "$TSIDP_CLIENT_SECRET" ]; then\n            if [ "$NON_INTERACTIVE" = true ]; then\n                log_error "OIDC mode requires TSIDP_URL, TSIDP_CLIENT_ID, and TSIDP_CLIENT_SECRET"\n                return 1\n            fi\n            log_warning "OIDC credentials not fully configured"\n        fi\n    fi\n\n    log_success "Configuration validated"\n    return 0\n}\n\n# Convert container names to IDs\nresolve_container_ids() {\n    local resolved_ids=()\n\n    if [ -n "$CONTAINER_NAMES" ]; then\n        log_info "Resolving container names to IDs..."\n\n        IFS=',' read -ra NAMES <<< "$CONTAINER_NAMES"\n        for name in "${NAMES[@]}"; do\n            name=$(echo "$name" | xargs)  # Trim whitespace\n            local ctid\n            ctid=$(pct list | awk -v name="$name" '$3 == name {print $1}')\n\n            if [ -n "$ctid" ]; then\n                resolved_ids+=("$ctid")\n                log_info "  $name -> $ctid"\n            else\n                log_error "Container not found: $name"\n                return 1\n            fi\n        done\n\n        # Merge with CONTAINERS if specified\n        if [ -n "$CONTAINERS" ]; then\n            CONTAINERS="$CONTAINERS,$(IFS=,; echo "${resolved_ids[*]}")"\n        else\n            CONTAINERS=$(IFS=,; echo "${resolved_ids[*]}")\n        fi\n    fi\n\n    # Remove duplicates and sort\n    CONTAINERS=$(echo "$CONTAINERS" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')\n\n    log_info "Target containers: $CONTAINERS"\n    return 0\n}\n\n# Prepare single container\nprepare_container() {\n    local ctid="$1"\n\n    log_section "Preparing Container $ctid"\n\n    # Check if container exists\n    if ! container_exists "$ctid"; then\n        if [ "$CREATE_CONTAINERS" = true ]; then\n            log_info "Container $ctid does not exist, creating..."\n\n            # Download template if needed\n            download_template "$CONTAINER_TEMPLATE" "$CONTAINER_STORAGE" || return 1\n\n            # Create container\n            create_container "$ctid" "$CONTAINER_TEMPLATE" "$CONTAINER_STORAGE" \\n                "$CONTAINER_DISK_SIZE" "$CONTAINER_MEMORY" "$CONTAINER_CORES" \\n                "${HOSTNAME_PREFIX}-${ctid}" || return 1\n        else\n            log_error "Container $ctid does not exist and CREATE_CONTAINERS=false"\n            return 1\n        fi\n    fi\n\n    # Ensure container is running\n    ensure_container_running "$ctid" || return 1\n\n    # Check and fix features if needed\n    if ! check_container_features "$ctid"; then\n        if [ "$AUTO_FIX_FEATURES" = true ]; then\n            log_info "Auto-fixing container features..."\n            fix_container_features "$ctid" || return 1\n        else\n            log_error "Container $ctid is missing required features. Set AUTO_FIX_FEATURES=true to fix automatically"\n            return 1\n        fi\n    fi\n\n    # Validate requirements\n    validate_container_requirements "$ctid" 1024 5 || {\n        log_warning "Container $ctid does not meet recommended requirements"\n        if [ "$CONTINUE_ON_FAILURE" != true ]; then\n            return 1\n        fi\n    }\n\n    log_success "Container $ctid is ready for installation"\n    return 0\n}\n\n# Get per-container configuration value\nget_container_override() {\n    local ctid="$1"\n    local key="$2"\n    local default="$3"\n    local varname="CONTAINER_CONFIG_${ctid}_${key}"\n\n    # Use indirect expansion to get the value\n    local value="${!varname:-}"\n\n    if [ -n "$value" ]; then\n        echo "$value"\n    else\n        echo "$default"\n    fi\n}\n\n# Install TailOpsMCP on a single container\ninstall_on_container() {\n    local ctid="$1"\n\n    log_section "Installing TailOpsMCP on Container $ctid"\n\n    # Get container-specific configuration\n    local port=$(get_container_override "$ctid" "PORT" "8080")\n    local auth_mode=$(get_container_override "$ctid" "AUTH_MODE" "$AUTH_MODE")\n    local shared_secret=$(get_container_override "$ctid" "SHARED_SECRET" "$SYSTEMMANAGER_SHARED_SECRET")\n\n    # Create temporary directory for installation files\n    local temp_dir="/tmp/tailops-install-$ctid"\n    mkdir -p "$temp_dir"\n\n    # Create container-specific config file\n    local container_config="$temp_dir/install.conf"\n    cat > "$container_config" << EOF\n# Auto-generated configuration for container $ctid\nSYSTEMMANAGER_INSTALL_DIR="$SYSTEMMANAGER_INSTALL_DIR"\nSYSTEMMANAGER_PORT=$port\nSYSTEMMANAGER_AUTH_MODE=$auth_mode\nSYSTEMMANAGER_REPO="$SYSTEMMANAGER_REPO"\nSYSTEMMANAGER_REPO_BRANCH="$SYSTEMMANAGER_REPO_BRANCH"\nNON_INTERACTIVE=true\nSKIP_DOCKER=$SKIP_DOCKER\nFORCE_REINSTALL=$FORCE_REINSTALL\nEOF\n\n    # Add auth-specific configuration\n    if [ "$auth_mode" = "token" ]; then\n        if [ -z "$shared_secret" ]; then\n            shared_secret=$(openssl rand -base64 32)\n            log_info "Generated shared secret for container $ctid"\n        fi\n        echo "SYSTEMMANAGER_SHARED_SECRET=\"$shared_secret\"" >> "$container_config"\n    elif [ "$auth_mode" = "oidc" ]; then\n        cat >> "$container_config" << EOF\nTSIDP_URL="$TSIDP_URL"\nTSIDP_CLIENT_ID="$TSIDP_CLIENT_ID"\nTSIDP_CLIENT_SECRET="$TSIDP_CLIENT_SECRET"\nEOF\n    fi\n\n    # Copy installation files to container\n    log_info "Copying installation files to container..."\n\n    # Copy the entire project directory\n    exec_in_container "$ctid" "rm -rf /tmp/tailops-install" || true\n    exec_in_container "$ctid" "mkdir -p /tmp/tailops-install"\n\n    # Create tarball and copy\n    local tarball="$temp_dir/tailops.tar.gz"\n    (cd "$PROJECT_ROOT" && tar czf "$tarball" \\n        "${TARBALL_EXCLUDES[@]}" \\n        .)\n\n    copy_to_container "$ctid" "$tarball" "/tmp/tailops.tar.gz" || return 1\n    exec_in_container "$ctid" "cd /tmp/tailops-install && tar xzf /tmp/tailops.tar.gz" || return 1\n\n    # Copy configuration\n    copy_to_container "$ctid" "$container_config" "/tmp/tailops-install/install.conf" || return 1\n\n    # Run installation\n    log_info "Running installation inside container..."\n    local install_cmd="cd /tmp/tailops-install && bash scripts/install/install-standalone.sh --config /tmp/tailops-install/install.conf"\n\n    if exec_in_container "$ctid" "$install_cmd"; then\n        log_success "Installation completed successfully on container $ctid"\n\n        # Get container IP\n        local ip\n        ip=$(get_container_ip "$ctid")\n        DEPLOYMENT_IPS[$ctid]="$ip"\n\n        # Store auth info for summary\n        if [ "$auth_mode" = "token" ]; then\n            DEPLOYMENT_ERRORS[$ctid]="Token: $shared_secret"\n        fi\n\n        DEPLOYMENT_STATUS[$ctid]="success"\n\n        # Clean up\n        exec_in_container "$ctid" "rm -rf /tmp/tailops-install /tmp/tailops.tar.gz"\n        rm -rf "$temp_dir"\n\n        return 0\n    else\n        log_error "Installation failed on container $ctid"\n        DEPLOYMENT_STATUS[$ctid]="failed"\n        DEPLOYMENT_ERRORS[$ctid]="Installation script failed"\n\n        # Keep files for debugging\n        log_info "Installation files kept in container:/tmp/tailops-install for debugging"\n\n        return 1\n    fi\n}\n\n# Validate installation on container\nvalidate_installation() {\n    local ctid="$1"\n\n    log_info "Validating installation on container $ctid..."\n\n    # Check if service is running\n    if ! exec_in_container "$ctid" "systemctl is-active systemmanager-mcp" >/dev/null 2>&1; then\n        log_error "Service is not running on container $ctid"\n        return 1\n    fi\n\n    # Check if port is listening\n    local port=$(get_container_override "$ctid" "PORT" "8080")\n    if ! exec_in_container "$ctid" "ss -tlnp | grep -q :$port" >/dev/null 2>&1; then\n        log_error "Service is not listening on port $port on container $ctid"\n        return 1\n    fi\n\n    log_success "Installation validated on container $ctid"\n    return 0\n}\n\n# Deploy to single container (wrapper for parallel execution)\ndeploy_container() {\n    local ctid="$1"\n\n    {\n        if prepare_container "$ctid" && \\n           install_on_container "$ctid" && \\n           ( [ "$RUN_VALIDATION" != true ] || validate_installation "$ctid" ); then\n            return 0\n        else\n            return 1\n        fi\n    } 2>&1 | sed "s/^/[CT$ctid] /"\n}\n\n# Deploy to all containers\ndeploy_all() {\n    log_section "Starting Multi-Container Deployment"\n\n    IFS=',' read -ra CTIDS <<< "$CONTAINERS"\n    local total=${#CTIDS[@]}\n    local current=0\n    local failed=0\n\n    log_info "Deploying to $total containers..."\n    log_info "Strategy: $DEPLOYMENT_STRATEGY"\n\n    if [ "$DEPLOYMENT_STRATEGY" = "parallel" ]; then\n        log_info "Running parallel deployment (max $MAX_PARALLEL at a time)..."\n\n        # Deploy in batches\n        local batch_size=$MAX_PARALLEL\n        local pids=()\n\n        for ctid in "${CTIDS[@]}"; do\n            ctid=$(echo "$ctid" | xargs)  # Trim whitespace\n\n            deploy_container "$ctid" &\n            pids+=($!)\n\n            # Wait if we've hit the batch size\n            if [ ${#pids[@]} -ge $batch_size ]; then\n                for pid in "${pids[@]}"; do\n                    if wait "$pid"; then\n                        ((current++))\n                    else\n                        ((failed++))\n                    fi\n                done\n                pids=()\n            fi\n        done\n\n        # Wait for remaining processes\n        for pid in "${pids[@]}"; do\n            if wait "$pid"; then\n                ((current++))\n            else\n                ((failed++))\n            fi\n        done\n\n    else\n        # Sequential deployment\n        for ctid in "${CTIDS[@]}"; do\n            ctid=$(echo "$ctid" | xargs)  # Trim whitespace\n            ((current++))\n\n            log_info "[$current/$total] Processing container $ctid..."\n\n            if deploy_container "$ctid"; then\n                log_success "Container $ctid deployed successfully"\n            else\n                log_error "Container $ctid deployment failed"\n                ((failed++))\n\n                if [ "$CONTINUE_ON_FAILURE" != true ]; then\n                    log_error "Stopping deployment due to failure (CONTINUE_ON_FAILURE=false)"\n                    break\n                fi\n            fi\n\n            echo ""\n        done\n    fi\n\n    log_section "Deployment Complete"\n    log_info "Total: $total | Success: $((total - failed)) | Failed: $failed"\n\n    if [ $failed -gt 0 ]; then\n        return 1\n    fi\n\n    return 0\n}\n\n# Show deployment summary\nshow_summary() {\n    log_section "Deployment Summary"\n\n    echo ""\n    echo "╔════════════════════════════════════════════════════════════════════╗"\n    echo "║          TailOpsMCP Multi-Container Deployment Summary             ║"\n    echo "╚════════════════════════════════════════════════════════════════════╝"\n    echo ""\n\n    printf "%-12s %-10s %-20s %s\n" "Container" "Status" "IP Address" "Notes"\n    printf "%-12s %-10s %-20s %s\n" "----------" "--------" "------------" "-----"\n\n    IFS=',' read -ra CTIDS <<< "$CONTAINERS"\n    for ctid in "${CTIDS[@]}"; do\n        ctid=$(echo "$ctid" | xargs)\n        local status="${DEPLOYMENT_STATUS[$ctid]:-unknown}"\n        local ip="${DEPLOYMENT_IPS[$ctid]:-N/A}"\n        local notes="${DEPLOYMENT_ERRORS[$ctid]:-}"\n\n        if [ "$status" = "success" ]; then\n            printf "%-12s \e[32m%-10s\e[0m %-20s %s\n" "$ctid" "✓ Success" "$ip" "$notes"\n        else\n            printf "%-12s \e[31m%-10s\e[0m %-20s %s\n" "$ctid" "✗ Failed" "$ip" "$notes"\n        fi\n    done\n\n    echo ""\n\n    # Show next steps\n    echo "Next Steps:"\n    echo ""\n    echo "1. Access your TailOpsMCP instances:"\n    for ctid in "${CTIDS[@]}"; do\n        ctid=$(echo "$ctid" | xargs)\n        if [ "${DEPLOYMENT_STATUS[$ctid]:-}" = "success" ]; then\n            local ip="${DEPLOYMENT_IPS[$ctid]:-}"\n            local port=$(get_container_override "$ctid" "PORT" "8080")\n            if [ -n "$ip" ]; then\n                echo "   Container $ctid: http://$ip:$port"\n            fi\n        fi\n    done\n    echo ""\n\n    echo "2. Check service status:"\n    echo "   pct exec <CTID> -- systemctl status systemmanager-mcp"\n    echo ""\n\n    echo "3. View logs:"\n    echo "   pct exec <CTID> -- journalctl -u systemmanager-mcp -f"\n    echo ""\n\n    echo "4. Configure Claude Desktop to use your instances"\n    echo "   See: docs/getting-started.md"\n    echo ""\n\n    if [ "$AUTH_MODE" = "token" ]; then\n        echo "5. Save your authentication tokens (shown in Notes column above)"\n        echo ""\n    fi\n\n    echo "═══════════════════════════════════════════════════════════════════════"\n}\n\n# Main execution\nmain() {\n    echo "╔════════════════════════════════════════════════════════════════════╗"\n    echo "║     TailOpsMCP Multi-Container Installation for Proxmox LXC        ║"\n    echo "╚════════════════════════════════════════════════════════════════════╝"\n    echo ""\n\n    # Parse arguments\n    parse_args "$@"\n\n    # Check we're on Proxmox host\n    check_proxmox_host || exit 1\n\n    # Load configuration\n    load_config\n\n    # Validate configuration\n    validate_config || exit 1\n\n    # Resolve container IDs from names if needed\n    resolve_container_ids || exit 1\n\n    # Show configuration summary\n    log_section "Configuration Summary"\n    log_info "Target containers: $CONTAINERS"\n    log_info "Create new containers: $CREATE_CONTAINERS"\n    log_info "Authentication mode: $AUTH_MODE"\n    log_info "Deployment strategy: $DEPLOYMENT_STRATEGY"\n    log_info "Auto-fix features: $AUTO_FIX_FEATURES"\n    log_info "Continue on failure: $CONTINUE_ON_FAILURE"\n    echo ""\n\n    # Confirm if interactive\n    if [ "$NON_INTERACTIVE" != true ]; then\n        read -p "Continue with deployment? (y/N) " -n 1 -r\n        echo ""\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            log_info "Deployment cancelled"\n            exit 0\n        fi\n    fi\n\n    # Execute deployment\n    if deploy_all; then\n        show_summary\n        log_success "Multi-container deployment completed successfully!"\n        exit 0\n    else\n        show_summary\n        log_error "Multi-container deployment completed with errors"\n        exit 1\n    fi\n}\n\n# Run main function\nmain "$@"\n
